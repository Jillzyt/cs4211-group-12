#define matchPoint 11;
#define winPoint 1;
var serve_counter = 0;

enum{ml, fzd, na};

var turn = na; //serve turn;
var wonGame = na;
var wonSet = na;

var ball = 5;

// Scores //
var mlScore = 0;
var fzdScore = 0;

// Set points // 
var mlSetPoint = 0;
var fzdSetPoint = 0;

var currSetServer = na;

// High level
MatchPt = [mlSetPoint == 0 && fzdSetPoint == 0] TieBreakGame; [mlSetPoint != winPoint && fzdSetPoint != winPoint] nextSetGame;
TieBreakGame = whoServeFirst; (mlServe [] fzdServe);
whoServeFirst = []i:{ml, fzd}@TossCoin{if (i == ml) {turn = 0; serve_counter = 0; currSetServer = ml} else {turn = 2; serve_counter = 2; currSetServer= fzd;}} -> Skip;

// Low level
////////////////
// RESET HERE (BELOW)
#define setNextServer {if (wonSet == ml) {
			mlSetPoint++;
		} else {
			fzdSetPoint++;
		};
		if (mlSetPoint == winPoint) {
			wonGame = ml;
		} else if (fzdSetPoint == winPoint) {
			wonGame = fzd;
		};
		if (currSetServer == ml) {
			turn = 2; serve_counter = 2; currSetServer = fzd; wonSet= na;
		} else {
			turn = 0; serve_counter = 0; currSetServer = ml; wonSet = na;
		}
		mlScore = 0; 
		fzdScore = 0;
		};

nextSetGame = {setNextServer;} -> (mlServe [] fzdServe) [] ([wonGame != na] GameOver -> Skip);
mlServe = [wonSet == na && (turn == 0) && wonGame == na] mlReady_serve -> mlServeGame [] [ wonSet == na && (turn == 1) && wonGame == na] mlReady_serve -> mlServeGame;
fzdServe = [wonSet == na && (turn == 2) && wonGame == na] fzdReady_serve -> fzdServeGame [] [ wonSet == na && (turn == 3) && wonGame == na] fzdReady_serve-> fzdServeGame;
NextPt = mlServe [] fzdServe [] ([wonSet != na] ready_nextGame -> nextSetGame);

#define determineSetWinner(i) {if (i == 0 && (fzdScore == matchPoint && fzdScore != mlScore + 1) || (fzdScore > matchPoint && fzdScore - mlScore >= 2)) { // If fzd reach 11 and ML does not reach 10 yet
			wonSet = fzd;
		} else if ((mlScore == matchPoint && fzdScore + 1 != mlScore) || (mlScore > matchPoint && mlScore - fzdScore >= 2)) { // If ml reach 11 and fzd does not reach 10 yet
			wonSet = ml;
		}};
		
#define determineNextServer(i) {call(determineSetWinner, i); if (wonSet == na) {
		if ((fzdScore > matchPoint && fzdScore - mlScore < 2) || (mlScore > matchPoint && mlScore - fzdScore < 2)) {
			if (serve_counter % 2 == 0) {
				turn = ml;
			} else {
				turn = fzd;
			}
			serve_counter++;
		}
		else {
			if (serve_counter % 4 == 0 || (serve_counter % 4 == 1) ) {
				turn = ml;
			} else {
				turn = fzd;
			}
			serve_counter++;
		}}};
		
// MA LONG SECTION
//Ma Long Serve Actions
mlServeGame() = pcase{
	10: serveSuccFHToss{ball = 3; serve_counter++} -> fzdRallyActions
	1: serveSuccFHPend{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccFHBackSpin{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccFHReversePend{ball = 3; serve_counter++} -> fzdRallyActions
	
	0: serveSuccBHToss{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHPend{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHBackSpin{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHReversePend{ball = 3; serve_counter++} -> fzdRallyActions
	
	25: serveSuccFHToss{ball = 4; serve_counter++} -> fzdRallyActions
	2: serveSuccFHPend{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccFHBackSpin{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccFHReversePend{ball = 4; serve_counter++} -> fzdRallyActions
	
	4: serveSuccBHToss{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHPend{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHBackSpin{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHReversePend{ball = 4; serve_counter++} -> fzdRallyActions
	
	0: serveFailFHToss{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHPend{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	
	0: serveFailBHToss{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHPend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

// Ma Long Rally Actions

//ML hit to Pos 3 using forehand
mlRallyActionsPosThreeForehand = pcase {
	0: attack -> mlRallyAttackActionsPosThreeForehand
	0: defense -> mlRallyDefensiveActionsPosThreeForehand
};

mlRallyAttackActionsPosThreeForehand = pcase {
	6:  attSuccFHLoop{ball=3} -> fzdRallyActions
	8:  attSuccFHDrive{ball=3} -> fzdRallyActions
	1:  attSuccFHFlick{ball=3} -> fzdRallyActions
	0:  attSuccFHDrive{ball=3} -> fzdRallyActions
	
	1: attFailFHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	6: attFailFHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	3: attFailFHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	2: attFailFHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyDefensiveActionsPosThreeForehand = pcase {
	2: defSuccFHBlock{ball=3} -> fzdRallyActions
	4: defSuccFHChop{ball=3} -> fzdRallyActions
	4: defSuccFHPush{ball=3} -> fzdRallyActions
	0: defSuccFHLob{ball=3} -> fzdRallyActions
	
	5: defFailFHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	6: defFailFHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 3 using backhand
mlRallyActionsPosThreeBackhand = pcase {
	0: attack -> mlRallyAttackActionsPosThreeForehand
	0: defense -> mlRallyDefensiveActionsPosThreeForehand
};

mlRallyAttackActionsPosThreeBackhand = pcase {
	12: attSuccBHLoop{ball=3} -> fzdRallyActions
	10: attSuccBHDrive{ball=3} -> fzdRallyActions
	16: attSuccBHFlick{ball=3} -> fzdRallyActions
	0: attSuccBHSmash{ball=3} -> fzdRallyActions
	
	3: attFailBHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	9: attFailBHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	1: attFailBHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	1: attFailBHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

mlRallyDefensiveActionsPosThreeBackhand = pcase {
	9: defSuccBHChop{ball=3} -> fzdRallyActions
	8: defSuccBHBlock{ball=3} -> fzdRallyActions
	5: defSuccBHPush{ball=3} -> fzdRallyActions
	0: defSuccBHLob{ball=3} -> fzdRallyActions
	
	4: defFailBHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	3: defFailBHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	3: defFailBHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailBHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 4 using forehand
mlRallyActionsPosFourForehand = pcase {
	0: attack -> mlRallyAttackActionsPosFourForehand
	0: defense -> mlRallyDefensiveActionsPosFourForehand
};

mlRallyAttackActionsPosFourForehand = pcase {
	6:  attSuccFHLoop{ball=4} -> fzdRallyActions
	3:  attSuccFHDrive{ball=4} -> fzdRallyActions
	4:  attSuccFHFlick{ball=4} -> fzdRallyActions
	3:  attSuccFHSmash{ball=4} -> fzdRallyActions
	
	1: attFailFHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	6: attFailFHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	3: attFailFHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	2: attFailFHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyDefensiveActionsPosFourForehand = pcase {
	10: defSuccFHBlock{ball=4} -> fzdRallyActions
	4: defSuccFHChop{ball=4} -> fzdRallyActions
	4: defSuccFHPush{ball=4} -> fzdRallyActions
	0: defSuccFHLob{ball=4} -> fzdRallyActions
	
	5: defFailFHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	6: defFailFHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 4 using backhand
mlRallyActionsPosFourBackhand = pcase {
	0: attack -> mlRallyAttackActionsPosFourBackhand
	0: defense -> mlRallyDefensiveActionsPosFourBackhand
};

mlRallyAttackActionsPosFourBackhand = pcase {
	6:  attSuccBHLoop{ball=4} -> fzdRallyActions
	2:  attSuccBHFlick{ball=4} -> fzdRallyActions
	1:  attSuccBHSmash{ball=4} -> fzdRallyActions
	0:  attSuccBHDrive{ball=4} -> fzdRallyActions
	
	3: attFailBHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	9: attFailBHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	1: attFailBHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	1: attFailBHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

mlRallyDefensiveActionsPosFourBackhand = pcase {
	4: defSuccBHChop{ball=4} -> fzdRallyActions
	6: defSuccBHBlock{ball=4} -> fzdRallyActions
	5: defSuccBHPush{ball=4} -> fzdRallyActions
	0: defSuccBHLob{ball=4} -> fzdRallyActions
	
	3: defFailBHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	3: defFailBHBLock{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: defFailBHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: defFailBHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyActions = pcase {
	0: PosThree -> mlRallyActionsPosThreeForehand [] mlRallyActionsPosThreeBackhand
	0: PosFour -> mlRallyActionsPosFourForehand [] mlRallyActionsPosFourBackhand	
};

// ZE DONG SECTION
// Ze Dong Serve Actions
fzdServeGame() = pcase{
	0: serveSuccFHToss{ball = 1; serve_counter++} -> mlRallyActions
	9: serveSuccFHReversePend{ball = 1; serve_counter++} -> mlRallyActions
	8: serveSuccFHPend{ball = 1; serve_counter++} -> mlRallyActions
	3: serveSuccFHBackSpin{ball = 1; serve_counter++} -> mlRallyActions
	
	0: serveSuccBHToss{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHReversePend{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHPend{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHBackSpin{ball = 1; serve_counter++} -> mlRallyActions
	
	0: serveSuccFHToss{ball = 2; serve_counter++} -> mlRallyActions
	13: serveSuccFHReversePend{ball = 2; serve_counter++} -> mlRallyActions
	11: serveSuccFHPend{ball = 2; serve_counter++} -> mlRallyActions
	1: serveSuccFHBackSpin{ball = 2; serve_counter++} -> mlRallyActions
	
	0: serveSuccBHToss{ball = 2; serve_counter++} -> mlRallyActions
	0: serveSuccBHReversePend{ball = 2; serve_counter++} -> mlRallyActions
	0: serveSuccBHPend{ball = 2; serve_counter++} -> mlRallyActions
	0: serveSuccBHBackSpin{ball = 2; serve_counter++} -> mlRallyActions
	
	0: serveFailFHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	
	0: serveFailBHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHBackSpin{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHReversePend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

//FZD hit to Pos 1 using forehand
fzdRallyActionsPosOneForehand = pcase {
	0: attack -> fzdRallyAttackActionsPosOneForehand
	0: defense -> fzdRallyDefensiveActionsPosOneForehand
};

fzdRallyAttackActionsPosOneForehand = pcase {
	6:  attSuccFHLoop{ball=1} -> mlRallyActions
	8:  attSuccFHDrive{ball=1} -> mlRallyActions
	1:  attSuccFHFlick{ball=1} -> mlRallyActions
	0:  attSuccFHDrive{ball=1} -> mlRallyActions
	
	1: attFailFHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	6: attFailFHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailFHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailFHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosOneForehand = pcase {
	2: defSuccFHBlock{ball=1} -> mlRallyActions
	4: defSuccFHChop{ball=1} -> mlRallyActions
	4: defSuccFHPush{ball=1} -> mlRallyActions
	0: defSuccFHLob{ball=1} -> mlRallyActions
	
	5: defFailFHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	6: defFailFHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 1 using backhand
fzdRallyActionsPosOneBackhand = pcase {
	0: attack -> fzdRallyAttackActionsPosOneBackhand
	0: defense -> fzdRallyDefensiveActionsPosOneBackhand
};

fzdRallyAttackActionsPosOneBackhand = pcase {
	6:  attSuccBHLoop{ball=1} -> mlRallyActions
	8:  attSuccBHDrive{ball=1} -> mlRallyActions
	1:  attSuccBHFlick{ball=1} -> mlRallyActions
	0:  attSuccBHDrive{ball=1} -> mlRallyActions
	
	1: attFailBHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	6: attFailBHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailBHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailBHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosOneBackhand = pcase {
	2: defSuccBHBlock{ball=1} -> mlRallyActions
	4: defSuccBHChop{ball=1} -> mlRallyActions
	4: defSuccBHPush{ball=1} -> mlRallyActions
	0: defSuccBHLob{ball=1} -> mlRallyActions
	
	5: defFailBHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	6: defFailBHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailBHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailBHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 2 using forehand
fzdRallyActionsPosTwoForehand = pcase {
	0: attack -> fzdRallyAttackActionsPosTwoForehand
	0: defense -> fzdRallyDefensiveActionsPosTwoForehand
};

fzdRallyAttackActionsPosTwoForehand = pcase {
	6:  attSuccFHLoop{ball=2} -> mlRallyActions
	8:  attSuccFHDrive{ball=2} -> mlRallyActions
	1:  attSuccFHFlick{ball=2} -> mlRallyActions
	0:  attSuccFHDrive{ball=2} -> mlRallyActions
	
	1: attFailFHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	6: attFailFHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailFHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailFHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosTwoForehand = pcase {
	2: defSuccFHBlock{ball=2} -> mlRallyActions
	4: defSuccFHChop{ball=2} -> mlRallyActions
	4: defSuccFHPush{ball=2} -> mlRallyActions
	0: defSuccFHLob{ball=2} -> mlRallyActions
	
	5: defFailFHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	6: defFailFHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 2 using backhand
fzdRallyActionsPosTwoBackhand = pcase {
	0: attack -> fzdRallyAttackActionsPosTwoBackhand
	0: defense -> fzdRallyDefensiveActionsPosTwoBackhand
};

fzdRallyAttackActionsPosTwoBackhand = pcase {
	6:  attSuccBHLoop{ball=2} -> mlRallyActions
	8:  attSuccBHDrive{ball=2} -> mlRallyActions
	1:  attSuccBHFlick{ball=2} -> mlRallyActions
	0:  attSuccBHDrive{ball=2} -> mlRallyActions
	
	1: attFailBHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	6: attFailBHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailbHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailBHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosTwoBackhand = pcase {
	2: defSuccBHBlock{ball=2} -> mlRallyActions
	4: defSuccBHChop{ball=2} -> mlRallyActions
	4: defSuccBHPush{ball=2} -> mlRallyActions
	0: defSuccBHLob{ball=2} -> mlRallyActions
	
	5: defFailBHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	6: defFailBHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailBHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailBHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

fzdRallyActions = pcase {
	0: PosOne -> fzdRallyActionsPosOneForehand [] fzdRallyActionsPosOneBackhand
	0: PosTwo -> fzdRallyActionsPosTwoForehand [] fzdRallyActionsPosTwoBackhand	
};

#define malongWins mlSetPoint == winPoint;
#define fzdWins fzdSetPoint == winPoint;
#assert MatchPt reaches malongWins with prob;
