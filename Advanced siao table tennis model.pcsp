#define matchPoint 11;
#define winPoint 1;
var serve_counter = 0;

enum{ml, fzd, na};

var turn = na; //serve turn;
var wonGame = na;
var wonSet = na;

var ball = 5;

// Scores //
var mlScore = 0;
var fzdScore = 0;

// Set points // 
var mlSetPoint = 0;
var fzdSetPoint = 0;

var currSetServer = na;

// High level
MatchPt = [mlSetPoint == 0 && fzdSetPoint == 0] TieBreakGame; [mlSetPoint != winPoint && fzdSetPoint != winPoint] nextSetGame;
TieBreakGame = whoServeFirst; (mlServe [] fzdServe);
whoServeFirst = []i:{ml, fzd}@TossCoin{if (i == ml) {turn = 0; serve_counter = 0; currSetServer = ml} else {turn = 2; serve_counter = 2; currSetServer= fzd;}} -> Skip;

// Low level
////////////////
// RESET HERE (BELOW)
#define setNextServer {if (wonSet == ml) {
			mlSetPoint++;
		} else {
			fzdSetPoint++;
		};
		if (mlSetPoint == winPoint) {
			wonGame = ml;
		} else if (fzdSetPoint == winPoint) {
			wonGame = fzd;
		};
		if (currSetServer == ml) {
			turn = 2; serve_counter = 2; currSetServer = fzd; wonSet= na;
		} else {
			turn = 0; serve_counter = 0; currSetServer = ml; wonSet = na;
		}
		mlScore = 0; 
		fzdScore = 0;
		};

nextSetGame = {setNextServer;} -> (mlServe [] fzdServe) [] ([wonGame != na] GameOver -> Skip);
mlServe = [wonSet == na && (turn == 0) && wonGame == na] mlReady_serve -> mlServeGame [] [ wonSet == na && (turn == 1) && wonGame == na] mlReady_serve -> mlServeGame;
fzdServe = [wonSet == na && (turn == 2) && wonGame == na] fzdReady_serve -> fzdServeGame [] [ wonSet == na && (turn == 3) && wonGame == na] fzdReady_serve-> fzdServeGame;
NextPt = mlServe [] fzdServe [] ([wonSet != na] ready_nextGame -> nextSetGame);

#define determineSetWinner(i) {if (i == 0 && (fzdScore == matchPoint && fzdScore != mlScore + 1) || (fzdScore > matchPoint && fzdScore - mlScore >= 2)) { // If fzd reach 11 and ML does not reach 10 yet
			wonSet = fzd;
		} else if ((mlScore == matchPoint && fzdScore + 1 != mlScore) || (mlScore > matchPoint && mlScore - fzdScore >= 2)) { // If ml reach 11 and fzd does not reach 10 yet
			wonSet = ml;
		}};
		
#define determineNextServer(i) {call(determineSetWinner, i); if (wonSet == na) {
		if ((fzdScore > matchPoint && fzdScore - mlScore < 2) || (mlScore > matchPoint && mlScore - fzdScore < 2)) {
			if (serve_counter % 2 == 0) {
				turn = ml;
			} else {
				turn = fzd;
			}
			serve_counter++;
		}
		else {
			if (serve_counter % 4 == 0 || (serve_counter % 4 == 1) ) {
				turn = ml;
			} else {
				turn = fzd;
			}
			serve_counter++;
		}}};
		
// MA LONG SECTION
//Ma Long Serve Actions
mlServeGame() = pcase{
	35: mlServeActionPosThreeForehand
	0: mlServeActionPosThreeBackhand
	50: mlServeActionPosFourForehand
	4: mlServeActionPosFourBackhand
};

mlServeActionPosThreeForehand = pcase {
	30: serveSuccFHToss{ball = 3; serve_counter++} -> fzdRallyActions
	1: serveSuccFHPend{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccFHBackSpin{ball = 3; serve_counter++} -> fzdRallyActions
	4: serveSuccFHReversePend{ball = 3; serve_counter++} -> fzdRallyActions
	
	0: serveFailFHToss{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHPend{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlServeActionPosThreeBackhand = pcase {
	0: serveSuccBHToss{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHPend{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHBackSpin{ball = 3; serve_counter++} -> fzdRallyActions
	0: serveSuccBHReversePend{ball = 3; serve_counter++} -> fzdRallyActions
	
	0: serveFailBHToss{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHPend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlServeActionPosFourForehand = pcase {
	43: serveSuccFHToss{ball = 4; serve_counter++} -> fzdRallyActions
	2: serveSuccFHPend{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccFHBackSpin{ball = 4; serve_counter++} -> fzdRallyActions
	4: serveSuccFHReversePend{ball = 4; serve_counter++} -> fzdRallyActions
	
	1: serveFailFHToss{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHPend{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlServeActionPosFourBackhand = pcase {
	4: serveSuccBHToss{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHPend{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHBackSpin{ball = 4; serve_counter++} -> fzdRallyActions
	0: serveSuccBHReversePend{ball = 4; serve_counter++} -> fzdRallyActions
	
	0: serveFailBHToss{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHPend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHBackSpin{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: serveFailBHReversePend{ball =5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

// Ma Long Rally Actions

//ML hit to Pos 3 using forehand
mlRallyActionsPosThreeForehand = pcase {
	23: attack -> mlRallyAttackActionsPosThreeForehand
	33: defense -> mlRallyDefensiveActionsPosThreeForehand
};

mlRallyAttackActionsPosThreeForehand = pcase {
	9:  attSuccFHLoop{ball=3} -> fzdRallyActions
	11:  attSuccFHDrive{ball=3} -> fzdRallyActions
	1:  attSuccFHFlick{ball=3} -> fzdRallyActions
	0:  attSuccFHDrive{ball=3} -> fzdRallyActions
	
	0: attFailFHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	6: attFailFHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	2: attFailFHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	1: attFailFHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyDefensiveActionsPosThreeForehand = pcase {
	5: defSuccFHBlock{ball=3} -> fzdRallyActions
	4: defSuccFHChop{ball=3} -> fzdRallyActions
	19: defSuccFHPush{ball=3} -> fzdRallyActions
	0: defSuccFHLob{ball=3} -> fzdRallyActions
	
	0: defFailFHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	15: defFailFHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	2: defFailFHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 3 using backhand
mlRallyActionsPosThreeBackhand = pcase {
	87: attack -> mlRallyAttackActionsPosThreeBackhand
	60: defense -> mlRallyDefensiveActionsPosThreeBackhand
};

mlRallyAttackActionsPosThreeBackhand = pcase {
	15: attSuccBHLoop{ball=3} -> fzdRallyActions
	12: attSuccBHDrive{ball=3} -> fzdRallyActions
	55: attSuccBHFlick{ball=3} -> fzdRallyActions
	1: attSuccBHSmash{ball=3} -> fzdRallyActions
	
	4: attFailBHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	4: attFailBHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: attFailBHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	2: attFailBHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

mlRallyDefensiveActionsPosThreeBackhand = pcase {
	10: defSuccBHChop{ball=3} -> fzdRallyActions
	19: defSuccBHBlock{ball=3} -> fzdRallyActions
	26: defSuccBHPush{ball=3} -> fzdRallyActions
	0: defSuccBHLob{ball=3} -> fzdRallyActions
	
	0: defFailBHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	3: defFailBHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailBHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailBHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 4 using forehand
mlRallyActionsPosFourForehand = pcase {
	28: attack -> mlRallyAttackActionsPosFourForehand
	46: defense -> mlRallyDefensiveActionsPosFourForehand
};

mlRallyAttackActionsPosFourForehand = pcase {
	9:  attSuccFHLoop{ball=4} -> fzdRallyActions
	8:  attSuccFHDrive{ball=4} -> fzdRallyActions
	5:  attSuccFHFlick{ball=4} -> fzdRallyActions
	6:  attSuccFHSmash{ball=4} -> fzdRallyActions
	
	2: attFailFHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	3: attFailFHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	4: attFailFHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	2: attFailFHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyDefensiveActionsPosFourForehand = pcase {
	13: defSuccFHBlock{ball=4} -> fzdRallyActions
	4: defSuccFHChop{ball=4} -> fzdRallyActions
	28: defSuccFHPush{ball=4} -> fzdRallyActions
	1: defSuccFHLob{ball=4} -> fzdRallyActions
	
	4: defFailFHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	10: defFailFHBlock{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	4: defFailFHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	0: defFailFHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

//ML hit to Pos 4 using backhand
mlRallyActionsPosFourBackhand = pcase {
	16: attack -> mlRallyAttackActionsPosFourBackhand
	33: defense -> mlRallyDefensiveActionsPosFourBackhand
};

mlRallyAttackActionsPosFourBackhand = pcase {
	6:  attSuccBHLoop{ball=4} -> fzdRallyActions
	8:  attSuccBHFlick{ball=4} -> fzdRallyActions
	1:  attSuccBHSmash{ball=4} -> fzdRallyActions
	0:  attSuccBHDrive{ball=4} -> fzdRallyActions
	
	3: attFailBHLoop{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	13: attFailBHFlick{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	3: attFailBHSmash{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
	3: attFailBHDrive{ball=5} -> {fzdScore++; call(determineNextServer, 0)} -> NextPt
};

mlRallyDefensiveActionsPosFourBackhand = pcase {
	4: defSuccBHChop{ball=4} -> fzdRallyActions
	6: defSuccBHBlock{ball=4} -> fzdRallyActions
	17: defSuccBHPush{ball=4} -> fzdRallyActions
	2: defSuccBHLob{ball=4} -> fzdRallyActions
	
	4: defFailBHChop{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	10: defFailBHBLock{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	4: defFailBHPush{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
	0: defFailBHLob{ball=5} -> {fzdScore++; call(determineNextServer, 0);} -> NextPt
};

mlRallyActions = pcase {
	218: PosThree -> mlRallyActionsPosThreeForehand [] mlRallyActionsPosThreeBackhand
	121: PosFour -> mlRallyActionsPosFourForehand [] mlRallyActionsPosFourBackhand	
};

// ZE DONG SECTION
// Ze Dong Serve Actions
fzdServeGame() = pcase{
	41: fzdServeActionsPosOneForehand
	0: fzdServeActionsPosOneBackhand
	53: fzdServeActionsPosTwoForehand
	1: fzdServeActionsPosTwoBackhand
};

fzdServeActionsPosOneForehand = pcase {
	0: serveSuccFHToss{ball = 1; serve_counter++} -> mlRallyActions
	14: serveSuccFHReversePend{ball = 1; serve_counter++} -> mlRallyActions
	24: serveSuccFHPend{ball = 1; serve_counter++} -> mlRallyActions
	3: serveSuccFHBackSpin{ball = 1; serve_counter++} -> mlRallyActions
	
	0: serveFailFHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdServeActionsPosOneBackhand = pcase {
	0: serveSuccBHToss{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHReversePend{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHPend{ball = 1; serve_counter++} -> mlRallyActions
	0: serveSuccBHBackSpin{ball = 1; serve_counter++} -> mlRallyActions
	
	0: serveFailBHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHBackSpin{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHReversePend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdServeActionsPosTwoForehand = pcase {
	0: serveSuccFHToss{ball = 2; serve_counter++} -> mlRallyActions
	18: serveSuccFHReversePend{ball = 2; serve_counter++} -> mlRallyActions
	34: serveSuccFHPend{ball = 2; serve_counter++} -> mlRallyActions
	1: serveSuccFHBackSpin{ball = 2; serve_counter++} -> mlRallyActions
	
	0: serveFailFHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHBackSpin{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailFHReversePend{ball =5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdServeActionsPosTwoBackhand = pcase {
	0: serveSuccBHToss{ball = 2; serve_counter++} -> mlRallyActions
	0: serveSuccBHReversePend{ball = 2; serve_counter++} -> mlRallyActions
	1: serveSuccBHPend{ball = 2; serve_counter++} -> mlRallyActions
	0: serveSuccBHBackSpin{ball = 2; serve_counter++} -> mlRallyActions
	
	0: serveFailBHToss{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHPend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHBackSpin{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: serveFailBHReversePend{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

//FZD hit to Pos 1 using forehand
fzdRallyActionsPosOneForehand = pcase {
	29: attack -> fzdRallyAttackActionsPosOneForehand
	19: defense -> fzdRallyDefensiveActionsPosOneForehand
};

fzdRallyAttackActionsPosOneForehand = pcase {
	13:  attSuccFHLoop{ball=1} -> mlRallyActions
	6:  attSuccFHDrive{ball=1} -> mlRallyActions
	2:  attSuccFHFlick{ball=1} -> mlRallyActions
	8:  attSuccFHSmash{ball=1} -> mlRallyActions
	
	2: attFailFHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailFHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	1: attFailFHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailFHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosOneForehand = pcase {
	7: defSuccFHBlock{ball=1} -> mlRallyActions
	3: defSuccFHChop{ball=1} -> mlRallyActions
	8: defSuccFHPush{ball=1} -> mlRallyActions
	0: defSuccFHLob{ball=1} -> mlRallyActions
	
	1: defFailFHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	1: defFailFHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	1: defFailFHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 1 using backhand
fzdRallyActionsPosOneBackhand = pcase {
	20: attack -> fzdRallyAttackActionsPosOneBackhand
	21: defense -> fzdRallyDefensiveActionsPosOneBackhand
};

fzdRallyAttackActionsPosOneBackhand = pcase {
	6:  attSuccBHLoop{ball=1} -> mlRallyActions
	8:  attSuccBHDrive{ball=1} -> mlRallyActions
	1:  attSuccBHFlick{ball=1} -> mlRallyActions
	0:  attSuccBHSmash{ball=1} -> mlRallyActions
	
	11: attFailBHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailBHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: attFailBHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	1: attFailBHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosOneBackhand = pcase {
	2: defSuccBHBlock{ball=1} -> mlRallyActions
	1: defSuccBHChop{ball=1} -> mlRallyActions
	17: defSuccBHPush{ball=1} -> mlRallyActions
	0: defSuccBHLob{ball=1} -> mlRallyActions
	
	6: defFailBHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	11: defFailBHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	1: defFailBHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	1: defFailBHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 2 using forehand
fzdRallyActionsPosTwoForehand = pcase {
	34: attack -> fzdRallyAttackActionsPosTwoForehand
	44: defense -> fzdRallyDefensiveActionsPosTwoForehand
};

fzdRallyAttackActionsPosTwoForehand = pcase {
	4:  attSuccFHLoop{ball=2} -> mlRallyActions
	7:  attSuccFHDrive{ball=2} -> mlRallyActions
	6:  attSuccFHFlick{ball=2} -> mlRallyActions
	16:  attSuccFHSmash{ball=2} -> mlRallyActions
	
	3: attFailFHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	2: attFailFHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	1: attFailFHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	3: attFailFHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosTwoForehand = pcase {
	4: defSuccFHBlock{ball=2} -> mlRallyActions
	3: defSuccFHChop{ball=2} -> mlRallyActions
	31: defSuccFHPush{ball=2} -> mlRallyActions
	1: defSuccFHLob{ball=2} -> mlRallyActions
	
	4: defFailFHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	14: defFailFHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailFHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

//FZD hit to Pos 2 using backhand
fzdRallyActionsPosTwoBackhand = pcase {
	99: attack -> fzdRallyAttackActionsPosTwoBackhand
	56: defense -> fzdRallyDefensiveActionsPosTwoBackhand
};

fzdRallyAttackActionsPosTwoBackhand = pcase {
	14:  attSuccBHLoop{ball=2} -> mlRallyActions
	11:  attSuccBHDrive{ball=2} -> mlRallyActions
	69:  attSuccBHFlick{ball=2} -> mlRallyActions
	3:  attSuccBHSmash{ball=2} -> mlRallyActions
	
	4: attFailBHFlick{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: attFailBHLoop{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	1: attFailbHDrive{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
	0: attFailBHSmash{ball=5} -> {mlScore++; call(determineNextServer, 1);} -> NextPt
};

fzdRallyDefensiveActionsPosTwoBackhand = pcase {
	13: defSuccBHBlock{ball=2} -> mlRallyActions
	8: defSuccBHChop{ball=2} -> mlRallyActions
	26: defSuccBHPush{ball=2} -> mlRallyActions
	3: defSuccBHLob{ball=2} -> mlRallyActions
	
	5: defFailBHPush{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	3: defFailBHBlock{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	3: defFailBHChop{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
	0: defFailBHLob{ball=5} -> {mlScore++; call(determineNextServer, 1)} -> NextPt
};

fzdRallyActions = pcase {
	89: PosOne -> fzdRallyActionsPosOneForehand [] fzdRallyActionsPosOneBackhand
	233: PosTwo -> fzdRallyActionsPosTwoForehand [] fzdRallyActionsPosTwoBackhand	
};

#define malongWins mlSetPoint == winPoint;
#define fzdWins fzdSetPoint == winPoint;
#assert MatchPt reaches malongWins with prob;
